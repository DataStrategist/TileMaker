---
title: "Introduction to TileMaker"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Meet the Tile

Dashboard Tiles/Notecards are a great way to visualize just one number, and make it big and pretty. They can emphasize results in an easily digestible and colourful format. This package dates back to the days before infoboxes and valueboxes were available from flexdashboard and shinydashboards, and I think due to it's flexibiility, it still has some utility.

This package uses Twitter's [Bootstrap](https://getbootstrap.com/), and pushes content into buttons that then have different functionality. These buttons are good for embedding in static reports, in Rmd files, and Shiny dashboards. See examples below!

Let's start small. Here's the most basic button:

```{r}
library(TileMaker) ## to install, use devtools::install_github("mexindian/TileMaker")
solo_box(value = 3.3, text="Important parameter")

```

^ The solo_box only represents one value. But that doesn't mean it's boring! Here's a fully featured `solo_box`:

```{r}
solo_box(value = 42, text = "Absolute truth", former=99,size = "lg", icon = "check",
                    type = "warning", link = "http://google.com", units = "kg", hover = "I believe in fairies", textModifier="h3")
```

As you can see, plenty of bells and whistles. Most of the stuff above is self explanatory, except for the `size` which represents the relative size of the button(`md` = medium, `lg` = large etc), and the `type`, which dictates the color using the css classes : Default, Primary, Success, Info, Warning, Danger (we are using Bootstrap Version 3 by default... more on that later).

Now let's meet the rest of the family:

### Let's go solo_gradient_box!!!

The solo_gradient box automatically changes colors from red to yellow to green based on a target and some thresholds. By default, the `target` is set to 100 and the thresholds are set to 50 and 90, but obviously those are customizeable.

```{r}
solo_gradient_box(value = 95,text="Grade 1")
solo_gradient_box(value = 80,text="Grade 2")
solo_gradient_box(value = 40,text="Grade 3")
```

Now let's change the target only, but leave the thresholds on their default values (set to 50% and 90% of targets respectively) .

```{r}
solo_gradient_box(value = 46,text="Customized target",target = 50)

```

The above shows up green, because 46 of 50 is still 92%, but if we change the thresholdHigh to 93%:

```{r}
solo_gradient_box(value = 46,text="Customized target<br>and threshold",target = 50,thresholdHigh = 93)
```

You can see that the box changes to orange since it's now between `thresholdHigh` and `thresholdLow`. By the way, the thresholds are optimistic (ie, round up (so 90=green and 50=orange on default settings), because juuuuuuuust passing feels awesome and juuuuuust failing feels terrible.

By the way, you will also notice the `<br>` above forcing a line break. Yes, that's right, text accepts full html code, writen natively!

### It's your turn, multi_box!

The `multi_box`, in contrast to the `solo_box`, takes multiple values in one button, providing an easy way to summarize a ton of information in one button.

```{r}
multi_box(values = c(4,5,6),text = c("Sally","George", "Mohammed"),icons = c("check","plus","calendar"),title = "Candidates")

```

Naturally, I was tempted to also construct a multi_gradient_box, but I haven't because it seemed messy to have the color be dominated by one of the many values... so I don't think it's very useful. But please open an Issue if you have a good use case.

### Last but not least, here's the tile_matrix

```{r}
suppressPackageStartupMessages(library(dplyr))
df <- data_frame(values = c(2,5,6),
                 text = c("Sally","George", "Mohammed"))
tile_matrix(df,values=values,text=text,target=10,thresholdHigh = 60,thresholdLow = 40)

```

^ As you can see, the `tile_matrix` creates several new solo_gradient_boxes and compiles them all into a matrix. The point of this is to easily visualize data from a dataset, and of course it takes a dataset as a first input in order to be tidyverse compliant. Some examples:

```{r}
mtcars %>%
  ## we can't feed `names(mtcars)` as an input, so let's assign it as a column heading
  mutate(names=rownames(mtcars)) %>%
  ## pipe the dataframe directly into the tile_matrix! 
  tile_matrix(values = "disp",text = "names",
              target = 500,thresholdHigh = 80,thresholdLow = 50)

```

The concept of the `tile_matrix` is to provide a quick way to visualize simple information... for example summaries. The fact that the thresholds scale automatically to the target is also then useful, since one need only set the target in order to quickly obtain actionable information. For example, if one wanted to quickly see diamond prices, we could:

```{r}
library(dplyr)
library(ggplot2)
df <- diamonds %>%
  group_by(color) %>% summarize(price=mean(price)) %>%
  ## Assume there was some former price that was a bit different
  mutate(old_price=price*(1-runif(n = 7,min=-.2,max = .5)))

tile_matrix(df,values = price,text = color,former=old_price,target=5000,roundVal = 0)
```

### What's this "former" business?

So we've talked about former a bunch, which provides a comparison to the displayed value. This is especially useful to measure performance increase or declines. In order to show the functionality, let's use a quite contrived scenario:

```{r}
suppressPackageStartupMessages(library(dplyr))
df <- data_frame(values=seq(from=0,to=100,by=10),
                 text="comparison to 50",
                 former=50)

## Let's pretend that all previous values were 50... so:
df %>% tile_matrix(data = df,values = values,text = text,former=former)
```

### Grammar of tile_maker
Buttons are put into a div (which is more or less an html "row"... kinda). And these divs are put into a finalizer.

```{r}
# Value1 = 88
# Value2 = 1985
# Value3 = 1.22
# Value4 = 30
# Value5 = 42
# 
# ## Make the buttons how you like
# Button1 <- solo_box(value = Value1, text = "Speed", units = "mph",type = "danger")
# Button2 <- solo_box(value = Value2, text = "Origin", type = "warning")
# Button3 <- solo_box(value = Value3, text = "Powah",  units = "GW",  hover = "Great Scott!",type="success")
# Button4 <- solo_box(value = Value4, text = "Heads turned",units = "K",type="info")
# Button5 <- solo_box(value = Value5, text = "Answer", hover = "Whales rule. Petunias suck",
#   link = "https://en.wikipedia.org/wiki/The_Hitchhiker%27s_Guide_to_the_Galaxy",type="primary")
# 
# ## Combine in 2 rows:
# Div1 <- div_maker(subtitle = "Future",Button1, Button2, Button3)
# Div2 <- div_maker(subtitle = "Effect", Button4, Button5)
# 
# ## Now put them all together:
# finisher(title="Important block",Div1, Div2)
```

This button displays from red to green depending on the value passed to it, the target and the threshold.



The way to control colors is using the bootstrap types, 
